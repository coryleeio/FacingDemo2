Turns go in phases:

Player
Allies
Enemies

There is a linked list of steps, each step is composed of concurrently executing actions.
A step is complete and is removed from the queue whenever all its actions are complete

You always start in the player phase as this is the only time the game saves.

Game actions are any action that may be animated that has a source and a target, they go into a global queue, and during one, you cannot save. They have offsets for where they can be placed. 

Mark all characters that act in this phase

If any steps are in the queue just keep looping on them and return

if(any actors that still need to act in phase remain)
	Calculate all desired moves for AIs, or wait for player controller determine its actions
	These are populated with an end turn action step that occurs after the ai actions or player actions which marks the character as having acted this turn.

	If any of the actions are waits, collect all waits and put them into a single step, otherwise grab one of the actors that would like to act, and put their desired actions into a step.  If it is the player, just do nothing and wait for the player controller to submit actions.

	When you build the entities' actions into a step, charge the time if they are an npc, or push time to everyone else if they are the player.
else
    Next phase

Flow controller at beginning of turn either waits for input from the player, or gets all the AI's next desired action.  If any of the AIs actions are waits, it gathers them all up into one step and executes it.


When damage comes in it needs to go into one function which parses it and decides on the messages to display.  This function will loop through and offer the entity's body and items to modify the incoming ability

==================================================================

Relationship of attacks, abilities, actions???

An attack is an action
Attack just looks at your equipped primary weapon, if you have none it uses
your body to derive damage. It will trigger on hit ability of your weapon, and possibly other abilities on your body / in your inventory / equipment

Actions are 
Move
Attack
Ranged attack
Use item
Pickup Item ground
Equip item from inventory
Equip item from ground
Swap equipment

Actions methods include virtual start, is done, do, exit, etc.
Actions also have a source and a list of targets which are just set by the controller/AI when they are constructed using the cursor
Actions have a cursor that they can use to assign targets, one of the cursors is 'self', and does not 
display a cursor and resolves instantly, for moves, equipping items, etc.
Actions have a time cost

CURSORS - Helps the player/controller / AI find the targets for the action they want to take
Move: Self
Attack: Hollow plus range 1
Ranged attack: Hollow plus range 5
Use item: Derived from item's ability
Pickup Item ground: Self
Equip item from inventory: Self
Equip item from ground: Self
Swap equipment: Self

An ability is ALSO an action, so it inherits start, is done, do etc, time cost, and a cursor.
Most on hit items will have time cost of 0, while on use will probably have a standard on use for most things with notable outliers.

Abilities have three notable things:

Trigger condition(An event that can cause this to check its conditions and possibly execute)
CanTrigger function(to check all conditions required to trigger)

Abilities have their source and target list set by the action that caused them to go off, they are added
to the flow controller queue if their condition is met, this allows them to go in the same step, the next step, etc.

Trigger conditions:
Can use delegates to fire the events.  You need individual events, because some of these require some context... possibly always just the ability that caused them? But an event would likely be easiest.
The abilities need to register for events, and deregister themselves when they go out of scope, only stuff on the current level should be registered to receive delegations

On attack(When i am about to hit someone else)
On hit by melee(On mutate function called, if cause is a melee attack)
On hit by spell(On mutate function called, if cause is a spell)
On received damage(fired after damage is received, to burn enemy, or something for example)
On will receive damage(fired before the damage part of an attack, so that damage can be lowered/ removed in certain circumstances( a DR stat should deal with this in most normal cases, but if something protects vs orcs only for example, it would go here.))
On equipped(this event will need equipped/unequipped bool, it will cause any worn effects to be added/removed)



Dye sizes/ attacks / attack parameters:

Attack parameters is
dye number
dye size
damage type
interpolation string

Items have a list of attack parameters, if that list is 0 you cant attack with it.
Body has a list of attack parameters, if that list is 0 you cant attack without a weapon.
If you attack, the attack action looks at your equipped weapon, and if not, falls back to your Body
it gets its dye number and size from one of your attack parameters.






YOU NEED TO FIGURE OUT HOW FLOOR TRIGGERS FIT INTO THIS, AS YOUR STAIRCASES REQUIRE A CONTEXTUAL INPUT PRESENTLY.

opt1: stairs are their own thing
opt2: stairs somehow use this new triggering system, which adds parameters to this new system.
opt3: 

